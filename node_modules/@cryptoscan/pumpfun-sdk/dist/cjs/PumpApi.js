"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PumpApi = void 0;
const ws_1 = __importDefault(require("ws"));
const swap_sdk_1 = require("@cryptoscan/swap-sdk");
const scanner_sdk_1 = require("@cryptoscan/scanner-sdk");
const web3_js_1 = require("@solana/web3.js");
const solana_wallet_sdk_1 = require("@cryptoscan/solana-wallet-sdk");
class PumpApi {
    params = {
        buySlippage: 1,
        sellSlippage: 10,
        bumpSlippage: 10,
        buyFee: 0.00005,
        sellFee: 0.00005,
        transferFee: 0.00005,
        connection: new web3_js_1.Connection('https://api.mainnet-beta.solana.com/'),
    };
    constructor(params) {
        if (params) {
            this.params = {
                ...this.params,
                ...params,
            };
        }
    }
    async buy(_params) {
        const params = {
            ..._params,
            type: 'swap',
            network: 'solana',
            service: 'pumpfun',
            amount: _params.sol,
            wallet: _params.payerWallet || _params.wallet,
            from: 'So11111111111111111111111111111111111111112',
            to: _params.coinAddress,
            fee: _params.fee || this.params.buyFee,
            slippage: _params.slippage || this.params.buySlippage,
            connection: this.params.connection,
        };
        return (0, swap_sdk_1.swap)(params);
    }
    async sell(_params) {
        let sol = _params.sol;
        let amount;
        if (!_params.sol) {
            const balance = await (0, solana_wallet_sdk_1.getBalance)(_params.wallet.publicKey.toString(), _params.coinAddress);
            amount = balance;
        }
        if (!amount) {
            amount = await (0, scanner_sdk_1.getRate)({
                network: 'solana',
                service: 'pumpfun',
                from: 'So11111111111111111111111111111111111111112',
                to: _params.coinAddress,
                amount: sol,
            }).then((r) => r?.amount);
        }
        if (!amount) {
            throw new Error('Failed to get price');
        }
        const params = {
            ..._params,
            type: 'swap',
            network: 'solana',
            service: 'pumpfun',
            amount,
            wallet: _params.payerWallet || _params.wallet,
            from: _params.coinAddress,
            to: 'So11111111111111111111111111111111111111112',
            fee: _params.fee || this.params.sellFee,
            slippage: _params.slippage || this.params.sellSlippage,
            connection: this.params.connection,
        };
        return (0, swap_sdk_1.swap)(params);
    }
    async transfer(_params) {
        let amount = _params.sol;
        if (!_params.sol) {
            amount = await (0, solana_wallet_sdk_1.getBalance)(_params.walletFrom.publicKey.toString());
        }
        if (!!_params.coinAddress || _params.coinAddress?.toLowerCase() === 'so11111111111111111111111111111111111111112') {
            amount = await (0, scanner_sdk_1.getRate)({
                network: 'solana',
                service: 'pumpfun',
                from: 'So11111111111111111111111111111111111111112',
                to: _params.coinAddress,
                amount,
            }).then((r) => r?.amount);
            if (!amount) {
                throw new Error('Failed to get price');
            }
        }
        const params = {
            ..._params,
            type: 'transfer',
            network: 'solana',
            wallet: _params.payerWallet || _params.walletFrom,
            coinAddress: _params.coinAddress || 'So11111111111111111111111111111111111111112',
            from: _params.walletFrom.publicKey.toString(),
            to: _params.walletTo.publicKey.toString(),
            amount: amount,
            fee: _params.fee || this.params.transferFee,
            connection: this.params.connection,
        };
        return (0, swap_sdk_1.swap)(params);
    }
    async listenTransactions(address, onTransaction) {
        throw new Error('is not implemented');
    }
    listenCoinBump(coinAddress, onBump) {
        return this.listenPumpFun((type, coin) => {
            if (type === 'tradeCreated' && coin.mint === coinAddress) {
                onBump(coin);
            }
        });
    }
    waitMint(coinAddress) {
        return new Promise((resolve) => {
            const stop = this.onMint((coin) => {
                if (coin.mint === coinAddress
                    || coin.symbol.toLowerCase() === coinAddress.toLowerCase()
                    || coin.name.toLowerCase() === coinAddress.toLowerCase()) {
                    stop();
                    resolve(coin);
                }
            });
        });
    }
    onMint(callback) {
        return this.listenPumpFun((_, coin) => {
            const duration = (Date.now() - coin.created_timestamp) / 1000;
            if (duration <= 2) {
                callback(coin);
            }
        });
    }
    onBump(callback) {
        return this.listenPumpFun((type, coin) => {
            if (type === 'tradeCreated') {
                callback(coin);
            }
        });
    }
    listenPumpFun(callback) {
        const socketUrl = 'wss://frontend-api.pump.fun/socket.io/?EIO=4&transport=websocket';
        let ws = new ws_1.default(socketUrl, undefined, {
        // agent: new SocksProxyAgent('socks://z34VxR:2rF0MqMYH1@46.8.223.195:5501'),
        });
        const close = () => {
            ws.close();
        };
        if (!ws) {
            console.log('no ws');
            return close;
        }
        ws.on('open', () => {
            console.log('Connected to the WebSocket');
            ws.send('40');
        });
        ws.on('message', (data) => {
            const text = data.toString('utf-8');
            try {
                const [type, coin] = JSON.parse(text.replace(/^42/, ''));
                if (!coin) {
                    return;
                }
                if ('data' in coin) {
                    callback(type, JSON.parse(coin.data.subscribe.data).payload);
                    return;
                }
                callback(type, coin);
            }
            catch {
            }
        });
        ws.on('close', async () => {
            console.log('Disconnected from the PumpApi WebSocket');
            new Promise((resolve) => setTimeout(resolve, 500));
            return this.listenPumpFun(callback);
        });
        ws.on('error', (error) => {
            console.error('WebSocket error:', error);
        });
        return close;
    }
}
exports.PumpApi = PumpApi;
